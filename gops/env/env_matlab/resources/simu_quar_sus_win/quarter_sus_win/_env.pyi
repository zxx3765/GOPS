"""
Define env-related bindings.
"""
from __future__ import annotations
import typing
__all__: list[str] = ['ActionRepeatMode', 'EnvSpec', 'IndexingMode']
class ActionRepeatMode:
    """
    Members:
    
      SUM_BREAK
    """
    SUM_BREAK: typing.ClassVar[ActionRepeatMode]  # value = <ActionRepeatMode.SUM_BREAK: 0>
    __members__: typing.ClassVar[dict[str, ActionRepeatMode]]  # value = {'SUM_BREAK': <ActionRepeatMode.SUM_BREAK: 0>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class EnvSpec:
    def __init__(self, id: str, reward_threshold: typing.SupportsFloat | None = None, max_episode_steps: typing.SupportsInt | None = None, indexing_mode: IndexingMode = ..., nondeterministic: bool = False, auto_reset: bool = False, strict_reset: bool = True, need_render: bool = False, action_repeat: typing.SupportsInt = 0, action_repeat_mode: ActionRepeatMode = ..., **kwargs) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def action_repeat(self) -> int:
        ...
    @property
    def action_repeat_mode(self) -> ActionRepeatMode:
        ...
    @property
    def auto_reset(self) -> bool:
        ...
    @property
    def id(self) -> str:
        ...
    @property
    def indexing_mode(self) -> IndexingMode:
        ...
    @property
    def kwargs(self) -> dict:
        ...
    @property
    def max_episode_steps(self) -> int | None:
        ...
    @property
    def need_render(self) -> bool:
        ...
    @property
    def nondeterministic(self) -> bool:
        ...
    @property
    def reward_threshold(self) -> float | None:
        ...
    @property
    def strict_reset(self) -> bool:
        ...
class IndexingMode:
    """
    Members:
    
      PRESERVE_EMPTY
    
      PRESERVE_FILL
    
      COMPRESS
    """
    COMPRESS: typing.ClassVar[IndexingMode]  # value = <IndexingMode.COMPRESS: 2>
    PRESERVE_EMPTY: typing.ClassVar[IndexingMode]  # value = <IndexingMode.PRESERVE_EMPTY: 0>
    PRESERVE_FILL: typing.ClassVar[IndexingMode]  # value = <IndexingMode.PRESERVE_FILL: 1>
    __members__: typing.ClassVar[dict[str, IndexingMode]]  # value = {'PRESERVE_EMPTY': <IndexingMode.PRESERVE_EMPTY: 0>, 'PRESERVE_FILL': <IndexingMode.PRESERVE_FILL: 1>, 'COMPRESS': <IndexingMode.COMPRESS: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
