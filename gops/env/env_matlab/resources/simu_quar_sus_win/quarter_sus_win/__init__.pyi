"""
"""
from __future__ import annotations
import collections.abc
import gymnasium.spaces.box
import numpy
import numpy.typing
import typing
from . import _env
from . import _sl
__all__: tuple = ('RawEnv', 'RawEnvVec', 'GymEnv', 'GymEnvVec', 'QuarterSusWin')
class GymEnv:
    action_space: typing.ClassVar[gymnasium.spaces.box.Box]  # value = Box(0.0, 1.0, (1,), float64)
    metadata: typing.ClassVar[dict] = {'render.modes': list()}
    observation_space: typing.ClassVar[gymnasium.spaces.box.Box]  # value = Box(0.0, 1.0, (4,), float64)
    reward_range: typing.ClassVar[tuple]  # value = (-inf, inf)
    def __enter__(self) -> typing.Any:
        ...
    def __exit__(self, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, spec: _env.EnvSpec) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def close(self) -> None:
        ...
    def render(self) -> None:
        ...
    def reset(self, *, seed: typing.SupportsInt | None = None, options: dict | None = None, preinit: collections.abc.Callable[[], None] = None, postinit: collections.abc.Callable[[], None] = None) -> tuple:
        ...
    def step(self, action: numpy.typing.NDArray[numpy.float64]) -> tuple:
        ...
    @property
    def model_class(self) -> QuarterSusWin:
        ...
    @property
    def spec(self) -> _env.EnvSpec:
        ...
    @property
    def unwrapped(self) -> typing.Any:
        ...
class GymEnvVec:
    metadata: typing.ClassVar[dict] = {'render.modes': list()}
    reward_range: typing.ClassVar[dict] = {'render.modes': list()}
    single_action_space: typing.ClassVar[gymnasium.spaces.box.Box]  # value = Box(0.0, 1.0, (1,), float64)
    single_observation_space: typing.ClassVar[gymnasium.spaces.box.Box]  # value = Box(0.0, 1.0, (4,), float64)
    def __enter__(self) -> typing.Any:
        ...
    def __exit__(self, arg0: typing.Any, arg1: typing.Any, arg2: typing.Any) -> bool:
        ...
    @typing.overload
    def __init__(self, batch_size: typing.SupportsInt) -> None:
        ...
    @typing.overload
    def __init__(self, batch_size: typing.SupportsInt, spec: _env.EnvSpec) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def at(self, arg0: typing.SupportsInt) -> GymEnv:
        ...
    def close(self) -> None:
        ...
    def render(self, mode: str = 'human') -> None:
        ...
    @typing.overload
    def reset(self) -> tuple:
        ...
    @typing.overload
    def reset(self, mask: numpy.typing.NDArray[numpy.bool]) -> tuple:
        ...
    @typing.overload
    def reset(self, indices: numpy.typing.NDArray[numpy.int64]) -> tuple:
        ...
    @typing.overload
    def seed(self) -> list[int]:
        ...
    @typing.overload
    def seed(self, seed: typing.SupportsInt) -> list[int]:
        ...
    def size(self) -> int:
        ...
    @typing.overload
    def step(self, action: numpy.typing.NDArray[numpy.float64]) -> tuple:
        ...
    @typing.overload
    def step(self, action: numpy.typing.NDArray[numpy.float64], mask: numpy.typing.NDArray[numpy.bool]) -> tuple:
        ...
    @typing.overload
    def step(self, action: numpy.typing.NDArray[numpy.float64], indices: numpy.typing.NDArray[numpy.int64]) -> tuple:
        ...
    @property
    def spec(self) -> _env.EnvSpec:
        ...
    @property
    def unwrapped(self) -> typing.Any:
        ...
class QuarterSusWin:
    class B_quarter_sus_win_T:
        dtype: typing.ClassVar[numpy.dtype[numpy.void]]  # value = dtype([('Constant', '<f8'), ('Constant3', '<f8'), ('Constant1', '<f8'), ('vs', '<f8'), ('Constant2', '<f8'), ('vu', '<f8'), ('Gain3', '<f8'), ('Saturation2', '<f8'), ('as', '<f8'), ('au', '<f8'), ('Gain_epcx', '<f8'), ('Add', '<f8')])
        def __copy__(self) -> QuarterSusWin.B_quarter_sus_win_T:
            ...
        def __deepcopy__(self, memo: dict) -> QuarterSusWin.B_quarter_sus_win_T:
            ...
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def numpy(self) -> numpy.typing.NDArray[QuarterSusWin.B_quarter_sus_win_T]:
            ...
        @property
        def Add(self) -> float:
            ...
        @Add.setter
        def Add(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Constant(self) -> float:
            ...
        @Constant.setter
        def Constant(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Constant1(self) -> float:
            ...
        @Constant1.setter
        def Constant1(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Constant2(self) -> float:
            ...
        @Constant2.setter
        def Constant2(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Constant3(self) -> float:
            ...
        @Constant3.setter
        def Constant3(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Gain3(self) -> float:
            ...
        @Gain3.setter
        def Gain3(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Gain_epcx(self) -> float:
            ...
        @Gain_epcx.setter
        def Gain_epcx(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Saturation2(self) -> float:
            ...
        @Saturation2.setter
        def Saturation2(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def as(self) -> float:
            ...
        @as.setter
        def as(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def au(self) -> float:
            ...
        @au.setter
        def au(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def vs(self) -> float:
            ...
        @vs.setter
        def vs(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def vu(self) -> float:
            ...
        @vu.setter
        def vu(self, arg0: typing.SupportsFloat) -> None:
            ...
    class DW_quarter_sus_win_T:
        dtype: typing.ClassVar[numpy.dtype[numpy.void]]  # value = dtype([('Memory_PreviousInput', '<f8'), ('NextOutput', '<f8'), ('RandSeed', '<u4'), ('xs0_DWORK1', '?'), ('xu0_DWORK1', '?'), ('vs0_DWORK1', '?'), ('vu0_DWORK1', '?')])
        vs0_DWORK1: bool
        vu0_DWORK1: bool
        xs0_DWORK1: bool
        xu0_DWORK1: bool
        def __copy__(self) -> QuarterSusWin.DW_quarter_sus_win_T:
            ...
        def __deepcopy__(self, memo: dict) -> QuarterSusWin.DW_quarter_sus_win_T:
            ...
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def numpy(self) -> numpy.typing.NDArray[QuarterSusWin.DW_quarter_sus_win_T]:
            ...
        @property
        def Memory_PreviousInput(self) -> float:
            ...
        @Memory_PreviousInput.setter
        def Memory_PreviousInput(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def NextOutput(self) -> float:
            ...
        @NextOutput.setter
        def NextOutput(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def RandSeed(self) -> int:
            ...
        @RandSeed.setter
        def RandSeed(self, arg0: typing.SupportsInt) -> None:
            ...
    class ExtU_quarter_sus_win_T:
        dtype: typing.ClassVar[numpy.dtype[numpy.void]]  # value = dtype([('Action', '<f8')])
        def __copy__(self) -> QuarterSusWin.ExtU_quarter_sus_win_T:
            ...
        def __deepcopy__(self, memo: dict) -> QuarterSusWin.ExtU_quarter_sus_win_T:
            ...
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def numpy(self) -> numpy.typing.NDArray[QuarterSusWin.ExtU_quarter_sus_win_T]:
            ...
        @property
        def Action(self) -> float:
            ...
        @Action.setter
        def Action(self, arg0: typing.SupportsFloat) -> None:
            ...
    class ExtY_quarter_sus_win_T:
        dtype: typing.ClassVar[numpy.dtype[numpy.void]]  # value = dtype({'names': ['obs', 'rew', 'done', 'info', 'act_real'], 'formats': [('<f8', (4,)), '<f8', '?', ('<f8', (8,)), '<f8'], 'offsets': [0, 32, 40, 48, 112], 'itemsize': 120})
        done: bool
        def __copy__(self) -> QuarterSusWin.ExtY_quarter_sus_win_T:
            ...
        def __deepcopy__(self, memo: dict) -> QuarterSusWin.ExtY_quarter_sus_win_T:
            ...
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def numpy(self) -> numpy.typing.NDArray[QuarterSusWin.ExtY_quarter_sus_win_T]:
            ...
        @property
        def act_real(self) -> float:
            ...
        @act_real.setter
        def act_real(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def info(self) -> numpy.typing.NDArray[numpy.float64]:
            ...
        @property
        def obs(self) -> numpy.typing.NDArray[numpy.float64]:
            ...
        @property
        def rew(self) -> float:
            ...
        @rew.setter
        def rew(self, arg0: typing.SupportsFloat) -> None:
            ...
    class InstP_quarter_sus_win_T:
        dtype: typing.ClassVar[numpy.dtype[numpy.void]]  # value = dtype({'names': ['Cs', 'G0', 'Ks', 'Kt', 'Q_F', 'Q_dot_s', 'Q_flec', 'Q_flec_t', 'a_max', 'a_min', 'b_deflec', 'bump_height', 'bump_lenth', 'bump_start', 'f0', 'ms', 'mu', 'omega_1', 'omega_2', 'omega_3', 'sine_amp', 'sine_freq', 'u', 'vs0', 'vu0', 'xs0', 'xu0', 'road_type'], 'formats': ['<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', '<f8', 'i1'], 'offsets': [0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128, 136, 144, 152, 160, 168, 176, 184, 192, 200, 208, 216], 'itemsize': 224})
        def __copy__(self) -> QuarterSusWin.InstP_quarter_sus_win_T:
            ...
        def __deepcopy__(self, memo: dict) -> QuarterSusWin.InstP_quarter_sus_win_T:
            ...
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def numpy(self) -> numpy.typing.NDArray[QuarterSusWin.InstP_quarter_sus_win_T]:
            ...
        @property
        def Cs(self) -> float:
            ...
        @Cs.setter
        def Cs(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def G0(self) -> float:
            ...
        @G0.setter
        def G0(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Ks(self) -> float:
            ...
        @Ks.setter
        def Ks(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Kt(self) -> float:
            ...
        @Kt.setter
        def Kt(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Q_F(self) -> float:
            ...
        @Q_F.setter
        def Q_F(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Q_dot_s(self) -> float:
            ...
        @Q_dot_s.setter
        def Q_dot_s(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Q_flec(self) -> float:
            ...
        @Q_flec.setter
        def Q_flec(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def Q_flec_t(self) -> float:
            ...
        @Q_flec_t.setter
        def Q_flec_t(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def a_max(self) -> float:
            ...
        @a_max.setter
        def a_max(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def a_min(self) -> float:
            ...
        @a_min.setter
        def a_min(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def b_deflec(self) -> float:
            ...
        @b_deflec.setter
        def b_deflec(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def bump_height(self) -> float:
            ...
        @bump_height.setter
        def bump_height(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def bump_lenth(self) -> float:
            ...
        @bump_lenth.setter
        def bump_lenth(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def bump_start(self) -> float:
            ...
        @bump_start.setter
        def bump_start(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def f0(self) -> float:
            ...
        @f0.setter
        def f0(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def ms(self) -> float:
            ...
        @ms.setter
        def ms(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def mu(self) -> float:
            ...
        @mu.setter
        def mu(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def omega_1(self) -> float:
            ...
        @omega_1.setter
        def omega_1(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def omega_2(self) -> float:
            ...
        @omega_2.setter
        def omega_2(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def omega_3(self) -> float:
            ...
        @omega_3.setter
        def omega_3(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def road_type(self) -> int:
            ...
        @road_type.setter
        def road_type(self, arg0: typing.SupportsInt) -> None:
            ...
        @property
        def sine_amp(self) -> float:
            ...
        @sine_amp.setter
        def sine_amp(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def sine_freq(self) -> float:
            ...
        @sine_freq.setter
        def sine_freq(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def u(self) -> float:
            ...
        @u.setter
        def u(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def vs0(self) -> float:
            ...
        @vs0.setter
        def vs0(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def vu0(self) -> float:
            ...
        @vu0.setter
        def vu0(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def xs0(self) -> float:
            ...
        @xs0.setter
        def xs0(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def xu0(self) -> float:
            ...
        @xu0.setter
        def xu0(self, arg0: typing.SupportsFloat) -> None:
            ...
    class XDis_quarter_sus_win_T:
        dtype: typing.ClassVar[numpy.dtype[numpy.void]]  # value = dtype([('xs0_CSTATE', '?'), ('xu0_CSTATE', '?'), ('vs0_CSTATE', '?'), ('vu0_CSTATE', '?'), ('Integrator_CSTATE', '?')])
        Integrator_CSTATE: bool
        vs0_CSTATE: bool
        vu0_CSTATE: bool
        xs0_CSTATE: bool
        xu0_CSTATE: bool
        def __copy__(self) -> QuarterSusWin.XDis_quarter_sus_win_T:
            ...
        def __deepcopy__(self, memo: dict) -> QuarterSusWin.XDis_quarter_sus_win_T:
            ...
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def numpy(self) -> numpy.typing.NDArray[QuarterSusWin.XDis_quarter_sus_win_T]:
            ...
    class X_quarter_sus_win_T:
        dtype: typing.ClassVar[numpy.dtype[numpy.void]]  # value = dtype([('xs0_CSTATE', '<f8'), ('xu0_CSTATE', '<f8'), ('vs0_CSTATE', '<f8'), ('vu0_CSTATE', '<f8'), ('Integrator_CSTATE', '<f8')])
        def __copy__(self) -> QuarterSusWin.X_quarter_sus_win_T:
            ...
        def __deepcopy__(self, memo: dict) -> QuarterSusWin.X_quarter_sus_win_T:
            ...
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def numpy(self) -> numpy.typing.NDArray[QuarterSusWin.X_quarter_sus_win_T]:
            ...
        @property
        def Integrator_CSTATE(self) -> float:
            ...
        @Integrator_CSTATE.setter
        def Integrator_CSTATE(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def vs0_CSTATE(self) -> float:
            ...
        @vs0_CSTATE.setter
        def vs0_CSTATE(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def vu0_CSTATE(self) -> float:
            ...
        @vu0_CSTATE.setter
        def vu0_CSTATE(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def xs0_CSTATE(self) -> float:
            ...
        @xs0_CSTATE.setter
        def xs0_CSTATE(self, arg0: typing.SupportsFloat) -> None:
            ...
        @property
        def xu0_CSTATE(self) -> float:
            ...
        @xu0_CSTATE.setter
        def xu0_CSTATE(self, arg0: typing.SupportsFloat) -> None:
            ...
    sample_time: typing.ClassVar[float] = 0.001
    quarter_sus_win_B: QuarterSusWin.B_quarter_sus_win_T
    quarter_sus_win_DW: QuarterSusWin.DW_quarter_sus_win_T
    quarter_sus_win_InstP: QuarterSusWin.InstP_quarter_sus_win_T
    quarter_sus_win_U: QuarterSusWin.ExtU_quarter_sus_win_T
    quarter_sus_win_X: QuarterSusWin.X_quarter_sus_win_T
    quarter_sus_win_XDis: QuarterSusWin.XDis_quarter_sus_win_T
    quarter_sus_win_Y: QuarterSusWin.ExtY_quarter_sus_win_T
    @staticmethod
    def terminate() -> None:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def initialize(self) -> None:
        ...
    def skip(self, n: typing.SupportsInt) -> None:
        """
        Skip n steps, using current model input
        """
    def step(self) -> None:
        ...
class RawEnv:
    def __init__(self) -> None:
        ...
    def reset(self) -> QuarterSusWin.ExtY_quarter_sus_win_T:
        ...
    @typing.overload
    def seed(self) -> list[int]:
        ...
    @typing.overload
    def seed(self, seed: typing.SupportsInt) -> list[int]:
        ...
    def step(self, action: QuarterSusWin.ExtU_quarter_sus_win_T) -> QuarterSusWin.ExtY_quarter_sus_win_T:
        ...
    @property
    def model_class(self) -> QuarterSusWin:
        ...
class RawEnvVec:
    def __init__(self, batch_size: typing.SupportsInt) -> None:
        ...
    def at(self, arg0: typing.SupportsInt) -> RawEnv:
        ...
    @typing.overload
    def reset(self) -> numpy.typing.NDArray[QuarterSusWin.ExtY_quarter_sus_win_T]:
        ...
    @typing.overload
    def reset(self, mask: numpy.typing.NDArray[numpy.bool]) -> numpy.typing.NDArray[QuarterSusWin.ExtY_quarter_sus_win_T]:
        ...
    @typing.overload
    def reset(self, indices: numpy.typing.NDArray[numpy.int64]) -> numpy.typing.NDArray[QuarterSusWin.ExtY_quarter_sus_win_T]:
        ...
    @typing.overload
    def seed(self) -> list[int]:
        ...
    @typing.overload
    def seed(self, seed: typing.SupportsInt) -> list[int]:
        ...
    def size(self) -> int:
        ...
    @typing.overload
    def step(self, action: numpy.typing.NDArray[QuarterSusWin.ExtU_quarter_sus_win_T]) -> numpy.typing.NDArray[QuarterSusWin.ExtY_quarter_sus_win_T]:
        ...
    @typing.overload
    def step(self, action: numpy.typing.NDArray[QuarterSusWin.ExtU_quarter_sus_win_T], mask: numpy.typing.NDArray[numpy.bool]) -> numpy.typing.NDArray[QuarterSusWin.ExtY_quarter_sus_win_T]:
        ...
    @typing.overload
    def step(self, action: numpy.typing.NDArray[QuarterSusWin.ExtU_quarter_sus_win_T], indices: numpy.typing.NDArray[numpy.int64]) -> numpy.typing.NDArray[QuarterSusWin.ExtY_quarter_sus_win_T]:
        ...
__author__: str = 'hjzsj'
__version__: str = '15.71'
